# SB-Tree

**SB-Tree (Segmented-Block Tree)** 是一种面向内存时间序列数据库的高吞吐索引结构。
本项目实现了论文提出的核心机制，使用 **C++17 + CMake + GoogleTest**。
目标是为高频写入、范围查询和并发访问提供高效的索引方案。

---

## 架构概览

-   **两层结构**
-   **搜索层 (Search Layer)**：维护已转换数据块 (DataBlock) 的有序 runs，并通过后台线程追加更新。读取线程使用快照 (snapshot) 保证一致性和无锁查询。
-   **数据层 (Data Layer)**：由不可变的 DataBlock 构成的链表，支持高效的点查与范围扫描。

-   **分段块 (Segmented Block)**
-   管理多个 Per-Thread Block (PTB)，承接活跃写入。
-   任一 PTB 填满触发“封印”：收集所有 PTB → 排序 → 切分为 DataBlock → 尾插到数据层。
-   封印后结果通过后台线程追加到搜索层。

-   **每线程数据块 (PTB)**
-   每个线程独占，避免锁竞争。
-   顺序写入，达到容量后等待统一转换。

-   **数据块 (DataBlock)**
-   固定大小（默认 4KB），存储有序 KV。
-   内建 N-ary 搜索表，快速定位桶后在桶内线性扫描。
-   一旦生成即不可变，支持无锁并发查询。

---

## 已实现功能

-   **插入操作 (Insert)**
-   新写入先定位到活跃的分段块，落到线程专属的 PTB。
-   当任一 PTB 填满时，触发分段块转换：收集所有 PTB → 排序 → 切分为 DataBlock → 尾插到数据层。
-   CAS 保证只有一个线程完成转换，其余线程切换到新的分段块继续写入。
-   转换后的 DataBlock run 入队索引任务，由后台线程追加到搜索层。

-   **并发语义**
-   **Insert vs Insert**：线程各写 PTB，避免锁竞争；分段块转换通过 CAS 保证唯一性。
-   **Insert vs Lookup/Scan**：
-   转换完成后，后台线程将 DataBlock run 追加到搜索层并发布快照。
-   查询 (`lookup` / `scan`) 只读快照，访问不可变 DataBlock，避免锁开销。
-   整体保证：高并发插入 + 无锁查询。

-   **查询接口**
-   `lookup(key)`：点查指定 Key。
-   `scan(L, R)`：范围扫描，支持跨 DataBlock。

-   **索引维护**
-   搜索层由后台索引线程维护，负责批量晋升。
-   读线程使用快照保证一致性和无锁读取。

-   **单元测试覆盖**
-   run 接缝正确性（无重复/遗漏）。
-   转换过程中仅允许一个线程执行。
-   多轮插入后全局有序性验证。
-   异步索引正确性。
-   并发插入与查询场景的稳定性。
-   所有测试已通过 ✅。

---

## 未来可考虑功能

-   **块级优化**
-   DataBlock 内部预取与向量化查找。
-   4KB 对齐，提升缓存友好性。
-   N-ary 桶参数的自适应调优。

-   **工程优化**
-   自定义内存分配器（NUMA-aware、thread-local freelist）。
-   更大规模基准测试，验证写入吞吐与查询延迟。
-   CI/CD 集成，自动化测试与性能分析。

-   **功能扩展**
-   支持延迟写入或乱序数据的处理策略。

```

```
